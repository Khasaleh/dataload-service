from pydantic import BaseModel, validator
from typing import List

class BrandBase(BaseModel):
    brand_name: str

class BrandCreate(BrandBase):
    pass

class Brand(BrandBase):
    # Assuming id is generated by DB, it's not part of create/upload
    # id: int
    pass

class BrandValidationResult(BaseModel):
    is_valid: bool = True
    errors: List[dict] = [] # E.g., {"line_number": 2, "field": "brand_name", "error": "is required"}


# ... (keep existing Brand models)

class AttributeBase(BaseModel):
    attribute_name: str
    allowed_values: str # Will be stored as pipe-separated string

class AttributeCreate(AttributeBase):
    pass

class Attribute(AttributeBase):
    # id: int # Assuming id is generated by DB
    pass

class AttributeValidationResult(BaseModel):
    is_valid: bool = True
    errors: List[dict] = [] # E.g., {"line_number": 2, "field": "attribute_name", "error": "is required"}


# ... (keep existing Brand and Attribute models)
from pydantic import conint # For constrained integers

class ReturnPolicyBase(BaseModel):
    return_policy_code: str
    name: str # Though not explicitly listed in validation rules, it's in sample CSV. Assume required.
    return_window_days: conint(ge=0) # Must be numeric, >= 0
    grace_period_days: conint(ge=0)  # Must be numeric, >= 0
    description: str = "" # Optional based on typical use, but present in sample

class ReturnPolicyCreate(ReturnPolicyBase):
    pass

class ReturnPolicy(ReturnPolicyBase):
    # id: int # Assuming id is generated by DB
    pass

class ReturnPolicyValidationResult(BaseModel):
    is_valid: bool = True
    errors: List[dict] = []
