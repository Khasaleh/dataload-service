"""create_price_table_and_update_relations

Revision ID: fd23333a9d9a
Revises: 3a017431437a
Create Date: 2025-06-21 22:12:14.698214

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'fd23333a9d9a'
down_revision: Union[str, None] = '0001' # Should point to the initial tables migration
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

# Schema constants from models.py or env.py
CATALOG_SCHEMA = "catalog_management" # os.getenv("CATALOG_SERVICE_SCHEMA", "catalog_management")
PUBLIC_SCHEMA = "public" # os.getenv("PUBLIC_SCHEMA_NAME", "public")


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('prices',
    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('business_details_id', sa.BigInteger(), nullable=False),
    sa.Column('product_id', sa.BigInteger(), nullable=True),
    sa.Column('sku_id', sa.Integer(), nullable=True),
    sa.Column('price', sa.Float(), nullable=False),
    sa.Column('discount_price', sa.Float(), nullable=True),
    sa.Column('cost_price', sa.Float(), nullable=True),
    sa.Column('currency', sa.String(length=10), nullable=True, server_default='USD'),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), onupdate=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['product_id'], [f'{PUBLIC_SCHEMA}.products.id'], name=op.f('fk_prices_product_id_products')),
    sa.ForeignKeyConstraint(['sku_id'], [f'{CATALOG_SCHEMA}.product_items.id'], name=op.f('fk_prices_sku_id_product_items')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_prices')),
    sa.UniqueConstraint('product_id', name=op.f('uq_price_product_id')),
    sa.UniqueConstraint('sku_id', name=op.f('uq_price_sku_id')),
    # CheckConstraint for (product_id IS NOT NULL AND sku_id IS NULL) OR (product_id IS NULL AND sku_id IS NOT NULL)
    # This might be better handled at the application layer or with more complex SQL if partial indices are not sufficient.
    # For simplicity in Alembic, we'll rely on the partial unique indexes below and application logic for now.
    schema=CATALOG_SCHEMA
    )
    op.create_index(op.f('ix_catalog_management_prices_business_details_id'), 'prices', ['business_details_id'], unique=False, schema=CATALOG_SCHEMA)
    op.create_index('idx_price_business_product', 'prices', ['business_details_id', 'product_id'], unique=True, schema=CATALOG_SCHEMA, postgresql_where=sa.text('product_id IS NOT NULL'))
    op.create_index('idx_price_business_sku', 'prices', ['business_details_id', 'sku_id'], unique=True, schema=CATALOG_SCHEMA, postgresql_where=sa.text('sku_id IS NOT NULL'))
    op.create_index(op.f('ix_catalog_management_prices_product_id'), 'prices', ['product_id'], unique=False, schema=CATALOG_SCHEMA)
    op.create_index(op.f('ix_catalog_management_prices_sku_id'), 'prices', ['sku_id'], unique=False, schema=CATALOG_SCHEMA)

    # Add/modify columns for relationships in ProductOrm and ProductItemOrm if needed
    # ProductOrm already has `prices = relationship("PriceOrm", ...)` which doesn't require a DB schema change itself.
    # ProductItemOrm also has `prices = relationship("PriceOrm", ...)`

    # Update ProductImageOrm to add ForeignKey for main_sku_id
    # This was added in models.py, ensure it's reflected here or in a previous/subsequent migration
    # op.add_column(f'{PUBLIC_SCHEMA}.product_images', sa.Column('main_sku_id', sa.BigInteger(), nullable=True))
    # op.create_foreign_key(
    #     op.f('fk_product_images_main_sku_id_product_items'),
    #     source_table='product_images', referent_table='product_items',
    #     local_cols=['main_sku_id'], remote_cols=['id'],
    #     source_schema=PUBLIC_SCHEMA, referent_schema=CATALOG_SCHEMA,
    #     ondelete='SET NULL' # Or appropriate action
    # )
    # op.create_index(op.f('ix_public_product_images_main_sku_id'), 'product_images', ['main_sku_id'], unique=False, schema=PUBLIC_SCHEMA)

    # It seems 'main_sku_id' was intended to be BigInteger in ProductImageOrm but product_items.id is Integer.
    # Adjusting ProductImageOrm.main_sku_id to be Integer to match product_items.id.
    # If product_items.id were to become BigInteger, this would need to match.
    # The model `ProductImageOrm` has `main_sku_id = Column(BigInteger, ForeignKey(f'{CATALOG_SCHEMA}.product_items.id', ...)`
    # The `product_items.id` is `Column(Integer, ...)`
    # This is a mismatch. For now, assuming product_items.id remains Integer.
    # Let's alter product_images table to add main_sku_id as Integer.
    # This should ideally be in the migration that introduced product_images or product_items if this link was intended then.
    # If this FK is new due to Price work, it's placed here.

    # Check if the column and FK already exist from a previous migration to avoid errors
    # For now, let's assume this is a new addition/correction for this migration.
    # The model shows `use_alter=True` for the FK on `main_sku_id` in `ProductImageOrm`
    # This implies it might be added to an existing table.

    # Add main_sku_id to product_images if it doesn't exist
    # Note: product_images.id is Integer, product_id is BigInt, main_sku_id should match product_items.id (Integer)
    # The model has ProductImageOrm.main_sku_id as BigInteger. This is a conflict.
    # Correcting to Integer based on product_items.id type.
    # This should be verified against the actual DDL/intent.
    # For now, I will comment out the product_images changes as there's a type conflict
    # and it's not directly part of price table creation itself but a relation fix.
    # This should be addressed in a separate, dedicated migration if confirmed.

    # Remove old ProductPriceOrm table if it exists and is truly replaced by PriceOrm
    # op.drop_table('product_prices', schema=CATALOG_SCHEMA) # Be cautious with dropping tables

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # op.add_column('product_prices', sa.Column('cost_per_item', sa.FLOAT(), autoincrement=False, nullable=True), schema=CATALOG_SCHEMA)
    # op.create_foreign_key('fk_product_prices_product_id_products', 'product_prices', 'products', ['product_id'], ['id'], source_schema=CATALOG_SCHEMA, referent_schema=CATALOG_SCHEMA)
    # op.create_unique_constraint('uq_product_prices_product_id', 'product_prices', ['product_id'], schema=CATALOG_SCHEMA)
    # op.create_index('ix_catalog_management_product_prices_business_details_id', 'product_prices', ['business_details_id'], unique=False, schema=CATALOG_SCHEMA)

    # op.drop_index(op.f('ix_public_product_images_main_sku_id'), table_name='product_images', schema=PUBLIC_SCHEMA)
    # op.drop_constraint(op.f('fk_product_images_main_sku_id_product_items'), 'product_images', schema=PUBLIC_SCHEMA, type_='foreignkey')
    # op.drop_column(f'{PUBLIC_SCHEMA}.product_images', 'main_sku_id')


    op.drop_index(op.f('ix_catalog_management_prices_sku_id'), table_name='prices', schema=CATALOG_SCHEMA)
    op.drop_index(op.f('ix_catalog_management_prices_product_id'), table_name='prices', schema=CATALOG_SCHEMA)
    op.drop_index('idx_price_business_sku', table_name='prices', schema=CATALOG_SCHEMA)
    op.drop_index('idx_price_business_product', table_name='prices', schema=CATALOG_SCHEMA)
    op.drop_index(op.f('ix_catalog_management_prices_business_details_id'), table_name='prices', schema=CATALOG_SCHEMA)
    op.drop_table('prices', schema=CATALOG_SCHEMA)
    # ### end Alembic commands ###
